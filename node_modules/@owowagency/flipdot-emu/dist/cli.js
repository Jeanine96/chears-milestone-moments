// src/renderer.ts
import { emitKeypressEvents } from "node:readline";
var TerminalOut = class {
  buffer = "";
  flush() {
    process.stdout.write(this.buffer);
    this.buffer = "";
  }
  moveCursor(x, y) {
    this.buffer += `\x1B[${y};${x}H`;
  }
  clear() {
    this.buffer += "\x1Bc";
  }
  hideCursor() {
    this.buffer += "\x1B[?25l";
  }
  showCursor() {
    this.buffer += "\x1B[?25h";
  }
  write(value) {
    this.buffer += value;
  }
};
var TerminalRenderer = class {
  width;
  height;
  out;
  previous;
  constructor(width, height) {
    this.width = width;
    this.height = height;
    this.out = new TerminalOut();
    this.previous = new Uint8Array(this.width * this.height);
  }
  getLuminanceRGB(r, g, b) {
    const luminance = (0.2126 * r + 0.7152 * g + 0.0722 * b) / 255;
    return luminance < 0.5 ? 0 : 1;
  }
  getPixel(data, index) {
    const r = data.data[index * 4 + 0];
    const g = data.data[index * 4 + 1];
    const b = data.data[index * 4 + 2];
    const a = data.data[index * 4 + 3];
    return this.getLuminanceRGB(r, g, b);
  }
  render(pixels2) {
    for (let x = 0; x < this.width; x += 1) {
      for (let y = 0; y < this.height / 2; y += 1) {
        const realY = y * 2;
        const topIndex = realY * this.width + x;
        const bottomIndex = (realY + 1) * this.width + x;
        const topPx = pixels2[topIndex];
        const bottomPx = pixels2[bottomIndex];
        const dirty = this.previous[topIndex] !== topPx || this.previous[bottomIndex] !== bottomPx;
        if (dirty) {
          this.write(x, y, topPx === 1, bottomPx === 1);
          this.previous[topIndex] = topPx;
          this.previous[bottomIndex] = bottomPx;
        }
      }
    }
    this.out.flush();
  }
  write(x, y, top, bottom) {
    this.out.moveCursor(x + 1, y + 1);
    const bg = top ? 47 : 40;
    const fg = bottom ? 37 : 30;
    this.out.write(`\x1B[0;${bg};${fg}m\u2584`);
  }
  fill() {
    for (let x = 0; x < this.width; x += 1) {
      for (let y = 0; y < this.height / 2; y += 1) {
        this.write(x, y, false, false);
      }
    }
    this.out.flush();
  }
  start() {
    const onExit = () => {
      this.out.clear();
      this.out.showCursor();
      this.out.flush();
      process.stdin.setRawMode(false);
      process.exit(0);
    };
    this.out.clear();
    this.out.hideCursor();
    this.out.flush();
    emitKeypressEvents(process.stdin);
    process.stdin.setRawMode(true);
    process.stdin.on("keypress", (chunk, key) => {
      if (key && key.name === "c" && key.ctrl) {
        onExit();
      }
    });
    this.fill();
    process.on("SIGINT", onExit);
  }
};

// src/panel.ts
var Panel = class {
  address;
  columns;
  command;
  dirty;
  constructor(address, width) {
    this.address = address;
    this.columns = new Uint8Array(width);
    this.columns.fill(0);
    this.command = new Uint8Array(1 + 1 + 1 + width + 1);
    this.dirty = true;
  }
  createCommand(flush) {
    this.command[0] = 128;
    this.command[1] = flush ? 131 : 132;
    this.command[2] = this.address;
    const imageDataOffset = 3;
    const endByteOffset = imageDataOffset + this.columns.length;
    for (let i = 0; i < this.columns.length; i += 1) {
      this.command[i + imageDataOffset] = this.columns[i];
    }
    this.command[endByteOffset] = 143;
    return this.command;
  }
  getPixel(x, y) {
    const col = this.columns[x];
    const mask = 1 << y - 1;
    return (col & mask) != 0;
  }
  setPixel(x, y, on) {
    let col = this.columns[x];
    const mask = 1 << y - 1;
    if (on) {
      col |= mask;
    } else {
      col &= ~mask;
    }
    if (this.columns[x] !== col) {
      this.dirty = true;
    }
    this.columns[x] = col;
  }
  putColumn(index, data) {
    if (this.columns[index] !== data) {
      this.dirty = true;
    }
    this.columns[index] = data;
  }
  markFlushed() {
    this.dirty = false;
  }
};

// src/transport.ts
import { Socket } from "node:net";
import { SerialPort } from "serialport";
function create(options) {
  switch (options.type) {
    case "ip":
      return new TcpTransport(options);
    case "stdout":
      return new StdoutTransport(true);
    case "noop":
      return new StdoutTransport(false);
    case "serial":
      return new SerialPortTransport(options);
  }
}
var StdoutTransport = class {
  enabled;
  constructor(enabled) {
    this.enabled = enabled;
  }
  send(data) {
    if (this.enabled) {
      const message = [...data.values()].map((b) => b.toString(16).padStart(2, "0")).join(" ");
      process.stdout.write(message);
      process.stdout.write("\n");
    }
    return true;
  }
  connect() {
    return Promise.resolve();
  }
};
var SerialPortTransport = class {
  port;
  reallyOpen = false;
  constructor(options) {
    this.port = new SerialPort({
      path: options.path,
      baudRate: options.baudRate
    }, (err) => {
      if (!err) {
        this.reallyOpen = true;
      }
    });
  }
  send(data) {
    if (this.reallyOpen) {
      this.port.write(data);
      return true;
    }
    return false;
  }
  connect() {
    return Promise.resolve();
  }
};
var TcpTransport = class {
  socket;
  host;
  port;
  constructor(options) {
    this.socket = new Socket();
    this.host = options.host;
    this.port = options.port;
  }
  send(data) {
    if (this.socket.readyState === "open") {
      this.socket.write(data);
      return true;
    }
    return false;
  }
  connect() {
    return new Promise((resolve, reject) => {
      this.socket.once("connect", () => {
        resolve();
      });
      this.socket.once("connectionAttemptFailed", () => {
        reject();
      });
      this.socket.connect(this.port, this.host);
    });
  }
};

// src/display.ts
var PANEL_HEIGHT = 7;
function getLuminanceRGB(r, g, b) {
  const luminance = (0.2126 * r + 0.7152 * g + 0.0722 * b) / 255;
  return luminance < 0.5 ? false : true;
}
function getPixel(data, index) {
  const r = data.data[index * 4 + 0];
  const g = data.data[index * 4 + 1];
  const b = data.data[index * 4 + 2];
  const a = data.data[index * 4 + 3];
  return getLuminanceRGB(r, g, b);
}
var Display = class {
  width;
  height;
  isMirrored;
  panels;
  panelWidth;
  transport;
  constructor(options) {
    this.isMirrored = options.isMirrored;
    this.panels = options.layout.map((row) => {
      return row.map((address) => new Panel(address, options.panelWidth));
    });
    const panelsVertical = options.layout.length;
    const panelsHorizontal = options.layout.map((row) => row.length).sort()[0];
    this.panelWidth = options.panelWidth;
    this.height = panelsVertical * PANEL_HEIGHT;
    this.width = panelsHorizontal * options.panelWidth;
    this.transport = create(options.transport);
  }
  setPixel(x, y, on) {
    const mirroredX = this.isMirrored ? this.width - 1 - x : x;
    const col = Math.floor(mirroredX / this.panelWidth);
    const row = Math.floor(y / PANEL_HEIGHT);
    const realX = mirroredX % this.panelWidth;
    const realY = this.isMirrored ? PANEL_HEIGHT - y % PANEL_HEIGHT : y % PANEL_HEIGHT;
    const panel = this.panels[row][col];
    return panel.setPixel(realX, realY, on);
  }
  getPixel(x, y) {
    const mirroredX = this.isMirrored ? this.width - 1 - x : x;
    const col = Math.floor(mirroredX / this.panelWidth);
    const row = Math.floor(y / PANEL_HEIGHT);
    const realX = mirroredX % this.panelWidth;
    const realY = this.isMirrored ? PANEL_HEIGHT - y % PANEL_HEIGHT : y % PANEL_HEIGHT;
    const panel = this.panels[row][col];
    return panel.getPixel(realX, realY);
  }
  getPanel(address) {
    for (let i = 0; i < this.panels.length; i += 1) {
      const row = this.panels[i];
      for (let j = 0; j < row.length; j += 1) {
        const p = row[j];
        if (p.address === address) {
          return p;
        }
      }
    }
    return null;
  }
  getDirtyPanels() {
    const dirty = [];
    for (const row of this.panels) {
      for (const panel of row) {
        if (panel.dirty) {
          dirty.push(panel);
        }
      }
    }
    return dirty;
  }
  flush() {
    const dirty = this.getDirtyPanels();
    for (let i = 0; i < dirty.length; i += 1) {
      const last = i >= dirty.length - 1;
      const panel = dirty[i];
      const command = panel.createCommand(true);
      const sent = this.transport.send(command);
      if (sent && last) {
        for (const p of dirty) {
          p.markFlushed();
        }
      }
    }
  }
  setImageData(data) {
    for (let x = 0; x < this.width; x += 1) {
      for (let y = 0; y < this.height; y += 1) {
        const pxIndex = y * this.width + x;
        const px = getPixel(data, pxIndex);
        this.setPixel(x, y, px);
      }
    }
  }
  isDirty() {
    for (const row of this.panels) {
      for (const p of row) {
        if (p.dirty) {
          return true;
        }
      }
    }
    return false;
  }
  connect() {
    this.transport.connect().then(() => {
      console.log("connected to display");
    }).catch(() => {
      console.error("Could not connect to display");
      process.exit(1);
    });
  }
};

// src/parser.ts
var Parser = class {
  state = "idle";
  flush = "unknown";
  panel = null;
  column = 0;
  onFlush;
  display;
  constructor(display2, onFlush) {
    this.display = display2;
    this.onFlush = onFlush;
  }
  push(data) {
    for (let index = 0; index < data.length; index += 1) {
      const byte = data[index];
      if (this.state === "idle") {
        if (byte === 128) {
          this.state = "command";
        } else {
          throw new Error("Did not expect this");
        }
        continue;
      }
      if (this.flush === "unknown") {
        if (byte === 131) {
          this.flush = "flush";
        } else if (byte === 132) {
          this.flush = "buffer";
        } else {
          throw new Error("Did not expect this");
        }
        continue;
      }
      if (this.panel === null) {
        this.panel = this.display.getPanel(byte);
        if (this.panel === null) {
          throw new Error("Could not find panel");
        }
        this.column = 0;
        continue;
      }
      if (byte === 143) {
        if (this.flush === "flush") {
          this.onFlush();
        }
        this.state = "idle";
        this.panel = null;
        this.flush = "unknown";
        continue;
      }
      this.panel.putColumn(this.column, byte);
      this.column += 1;
    }
  }
};

// src/server.ts
import { createServer } from "node:net";
var Server = class {
  host;
  port;
  parser;
  server;
  connections;
  constructor(host, port, parser2) {
    this.host = host;
    this.port = port;
    this.parser = parser2;
    this.server = createServer(this.onConnection.bind(this));
    this.connections = {};
  }
  onConnection(socket) {
    const id = crypto.randomUUID();
    const removeListeners = () => {
      socket.off("end", onEnd);
      socket.off("data", onData);
    };
    const onEnd = () => {
      delete this.connections[id];
      removeListeners();
    };
    const onData = (data) => {
      this.parser.push(data);
    };
    socket.on("end", onEnd);
    socket.on("data", onData);
  }
  listen() {
    this.server.listen(this.port, this.host);
  }
};

// src/cli.ts
function parsePort() {
  const pattern = /(-p|--port)=(?<port>\d+)/;
  const match = process.argv.map((arg) => arg.trim().match(pattern))[0];
  if (match) {
    return Number.parseInt(match.groups["port"]);
  }
  return 3e3;
}
function parseHost() {
  const pattern = /(-h|--host)=(?<host>.+)/;
  const match = process.argv.map((arg) => arg.trim().match(pattern))[0];
  if (match) {
    return match.groups["host"];
  }
  return "127.0.0.1";
}
var PORT = parsePort();
var HOST = parseHost();
var display = new Display({
  layout: [
    [3, 2, 1],
    [4, 5, 6],
    [9, 8, 7],
    [10, 11, 12]
  ],
  panelWidth: 28,
  isMirrored: true,
  transport: {
    type: "noop"
  }
});
var pixels = new Uint8Array(display.width * display.height);
var renderer = new TerminalRenderer(display.width, display.height);
function render() {
  for (let x = 0; x < display.width; x += 1) {
    for (let y = 0; y < display.height; y += 1) {
      const px = display.getPixel(x, y);
      const index = y * display.width + x;
      pixels[index] = px ? 1 : 0;
    }
  }
  renderer.render(pixels);
}
var parser = new Parser(display, render);
var server = new Server(HOST, PORT, parser);
server.listen();
renderer.start();
