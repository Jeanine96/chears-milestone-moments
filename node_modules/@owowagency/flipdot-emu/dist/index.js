// src/panel.ts
var Panel = class {
  address;
  columns;
  command;
  dirty;
  constructor(address, width) {
    this.address = address;
    this.columns = new Uint8Array(width);
    this.columns.fill(0);
    this.command = new Uint8Array(1 + 1 + 1 + width + 1);
    this.dirty = true;
  }
  createCommand(flush) {
    this.command[0] = 128;
    this.command[1] = flush ? 131 : 132;
    this.command[2] = this.address;
    const imageDataOffset = 3;
    const endByteOffset = imageDataOffset + this.columns.length;
    for (let i = 0; i < this.columns.length; i += 1) {
      this.command[i + imageDataOffset] = this.columns[i];
    }
    this.command[endByteOffset] = 143;
    return this.command;
  }
  getPixel(x, y) {
    const col = this.columns[x];
    const mask = 1 << y - 1;
    return (col & mask) != 0;
  }
  setPixel(x, y, on) {
    let col = this.columns[x];
    const mask = 1 << y - 1;
    if (on) {
      col |= mask;
    } else {
      col &= ~mask;
    }
    if (this.columns[x] !== col) {
      this.dirty = true;
    }
    this.columns[x] = col;
  }
  putColumn(index, data) {
    if (this.columns[index] !== data) {
      this.dirty = true;
    }
    this.columns[index] = data;
  }
  markFlushed() {
    this.dirty = false;
  }
};

// src/transport.ts
import { Socket } from "node:net";
import { SerialPort } from "serialport";
function create(options) {
  switch (options.type) {
    case "ip":
      return new TcpTransport(options);
    case "stdout":
      return new StdoutTransport(true);
    case "noop":
      return new StdoutTransport(false);
    case "serial":
      return new SerialPortTransport(options);
  }
}
var StdoutTransport = class {
  enabled;
  constructor(enabled) {
    this.enabled = enabled;
  }
  send(data) {
    if (this.enabled) {
      const message = [...data.values()].map((b) => b.toString(16).padStart(2, "0")).join(" ");
      process.stdout.write(message);
      process.stdout.write("\n");
    }
    return true;
  }
  connect() {
    return Promise.resolve();
  }
};
var SerialPortTransport = class {
  port;
  reallyOpen = false;
  constructor(options) {
    this.port = new SerialPort({
      path: options.path,
      baudRate: options.baudRate
    }, (err) => {
      if (!err) {
        this.reallyOpen = true;
      }
    });
  }
  send(data) {
    if (this.reallyOpen) {
      this.port.write(data);
      return true;
    }
    return false;
  }
  connect() {
    return Promise.resolve();
  }
};
var TcpTransport = class {
  socket;
  host;
  port;
  constructor(options) {
    this.socket = new Socket();
    this.host = options.host;
    this.port = options.port;
  }
  send(data) {
    if (this.socket.readyState === "open") {
      this.socket.write(data);
      return true;
    }
    return false;
  }
  connect() {
    return new Promise((resolve, reject) => {
      this.socket.once("connect", () => {
        resolve();
      });
      this.socket.once("connectionAttemptFailed", () => {
        reject();
      });
      this.socket.connect(this.port, this.host);
    });
  }
};

// src/display.ts
var PANEL_HEIGHT = 7;
function getLuminanceRGB(r, g, b) {
  const luminance = (0.2126 * r + 0.7152 * g + 0.0722 * b) / 255;
  return luminance < 0.5 ? false : true;
}
function getPixel(data, index) {
  const r = data.data[index * 4 + 0];
  const g = data.data[index * 4 + 1];
  const b = data.data[index * 4 + 2];
  const a = data.data[index * 4 + 3];
  return getLuminanceRGB(r, g, b);
}
var Display = class {
  width;
  height;
  isMirrored;
  panels;
  panelWidth;
  transport;
  constructor(options) {
    this.isMirrored = options.isMirrored;
    this.panels = options.layout.map((row) => {
      return row.map((address) => new Panel(address, options.panelWidth));
    });
    const panelsVertical = options.layout.length;
    const panelsHorizontal = options.layout.map((row) => row.length).sort()[0];
    this.panelWidth = options.panelWidth;
    this.height = panelsVertical * PANEL_HEIGHT;
    this.width = panelsHorizontal * options.panelWidth;
    this.transport = create(options.transport);
  }
  setPixel(x, y, on) {
    const mirroredX = this.isMirrored ? this.width - 1 - x : x;
    const col = Math.floor(mirroredX / this.panelWidth);
    const row = Math.floor(y / PANEL_HEIGHT);
    const realX = mirroredX % this.panelWidth;
    const realY = this.isMirrored ? PANEL_HEIGHT - y % PANEL_HEIGHT : y % PANEL_HEIGHT;
    const panel = this.panels[row][col];
    return panel.setPixel(realX, realY, on);
  }
  getPixel(x, y) {
    const mirroredX = this.isMirrored ? this.width - 1 - x : x;
    const col = Math.floor(mirroredX / this.panelWidth);
    const row = Math.floor(y / PANEL_HEIGHT);
    const realX = mirroredX % this.panelWidth;
    const realY = this.isMirrored ? PANEL_HEIGHT - y % PANEL_HEIGHT : y % PANEL_HEIGHT;
    const panel = this.panels[row][col];
    return panel.getPixel(realX, realY);
  }
  getPanel(address) {
    for (let i = 0; i < this.panels.length; i += 1) {
      const row = this.panels[i];
      for (let j = 0; j < row.length; j += 1) {
        const p = row[j];
        if (p.address === address) {
          return p;
        }
      }
    }
    return null;
  }
  getDirtyPanels() {
    const dirty = [];
    for (const row of this.panels) {
      for (const panel of row) {
        if (panel.dirty) {
          dirty.push(panel);
        }
      }
    }
    return dirty;
  }
  flush() {
    const dirty = this.getDirtyPanels();
    for (let i = 0; i < dirty.length; i += 1) {
      const last = i >= dirty.length - 1;
      const panel = dirty[i];
      const command = panel.createCommand(true);
      const sent = this.transport.send(command);
      if (sent && last) {
        for (const p of dirty) {
          p.markFlushed();
        }
      }
    }
  }
  setImageData(data) {
    for (let x = 0; x < this.width; x += 1) {
      for (let y = 0; y < this.height; y += 1) {
        const pxIndex = y * this.width + x;
        const px = getPixel(data, pxIndex);
        this.setPixel(x, y, px);
      }
    }
  }
  isDirty() {
    for (const row of this.panels) {
      for (const p of row) {
        if (p.dirty) {
          return true;
        }
      }
    }
    return false;
  }
  connect() {
    this.transport.connect().then(() => {
      console.log("connected to display");
    }).catch(() => {
      console.error("Could not connect to display");
      process.exit(1);
    });
  }
};
export {
  Display,
  Panel
};
